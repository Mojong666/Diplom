# **Сравнение подходов к асинхронному программированию в Python**
## **Введение**
Асинхронное программирование в Python становится все более важным в разработке высокопроизводительных и масштабируемых приложений. Этот проект посвящен сравнительному анализу трех ключевых подходов к асинхронному программированию: asyncio, threading и multiprocessing. Цель исследования заключается в оценке производительности и уместности каждого подхода в зависимости от типа задач.
## **Структура проекта**
1. **Асинхронное программирование** - Введение в основные концепции асинхронного программирования и его важность.
2. **Threading** - Использование потоков для выполнения задач параллельно в рамках одного процесса.
3. **Multiprocessing** - Запуск нескольких процессов для выполнения задач одновременно, с возможностью задействования нескольких ядер процессора.
4. **Asyncio** - Использование библиотеки asyncio для асинхронного выполнения задач с использованием синтаксиса async/await.
5. **Сравнение Подходов** - Реализация задач с использованием всех трех подходов и сравнительный анализ их производительности.
6. **Реализация Эксперимента** - Проведение тестов и сбор данных для оценки производительности каждого подхода.
## Основные понятия
+ **Асинхронное программирование**: Позволяет выполнять задачи параллельно, не блокируя основной поток выполнения программы.
+ **Threading**: Механизм многопоточности для параллельного выполнения задач в рамках одного процесса.
+ **Multiprocessing**: Запуск нескольких процессов, каждый из которых выполняется независимо от других.
+ **Asyncio**: Библиотека для написания асинхронного кода с использованием синтаксиса async/await.
## Методы реализации
Проект включает примеры использования всех трех подходов для различных типов задач:
1. **I/O-bound задачи** - Например, асинхронная загрузка данных с веб-сервера.
2. **CPU-bound задачи** - Выполнение вычислительно сложных операций, таких как вычисление чисел Фибоначчи.
3. **Задачи с высокой параллельностью** - Массовая обработка небольших файлов или данных.
## Пример использования multiprocessing
```
import multiprocessing  # Импортируем модуль для создания и управления параллельными процессами
import time  # Импортируем модуль для работы с временем (например, для измерения времени выполнения)
import tracemalloc  # Импортируем модуль для отслеживания использования памяти (профилирования)
import psutil  # Импортируем модуль для получения информации о процессах и использовании ресурсов системы


def fibonacci(n):
    if n <= 1:  # Если n равно 0 или 1, функция возвращает n (базовые случаи)
        return n
    else:  # Для всех других значений n функция рекурсивно вычисляет сумму двух предыдущих чисел Фибоначчи
        return fibonacci(n - 1) + fibonacci(n - 2)


def worker(n, queue):
    result = fibonacci(n)  # Вычисляем число Фибоначчи для n
    queue.put(result)  # Помещаем результат в очередь для передачи данных между процессами


def multiprocessing_main():
    numbers = [30, 32, 34]  # Задаем список чисел, для которых нужно вычислить числа Фибоначчи
    queue = multiprocessing.Queue()  # Создаем очередь для межпроцессной коммуникации
    processes = []  # Создаем список для хранения процессов

    for number in numbers:  # Для каждого числа в списке
        process = multiprocessing.Process(target=worker,
                                          args=(number, queue))  # Создаем новый процесс для вычисления числа Фибоначчи
        processes.append(process)  # Добавляем процесс в список
        process.start()  # Запускаем процесс

    for process in processes:  # Ожидаем завершения всех процессов
        process.join()

    results = [queue.get() for _ in range(len(numbers))]  # Извлекаем результаты из очереди
    return results  # Возвращаем результаты вычислений


def profile_multiprocessing_computation():
    tracemalloc.start()  # Запускаем профилирование использования памяти

    start_time = time.time()  # Сохраняем текущее время перед началом вычислений
    multiprocessing_main()  # Запускаем основную функцию с параллельными вычислениями
    end_time = time.time()  # Сохраняем время после завершения вычислений

    process = psutil.Process()  # Получаем информацию о текущем процессе
    mem_usage = process.memory_info().rss / (1024 * 1024)  # Получаем использование памяти в мегабайтах

    print("Multiprocessing computation time:", end_time - start_time)  # Выводим время выполнения
    print(f"Memory usage: {mem_usage:.2f} MB")  # Выводим использование памяти


if __name__ == '__main__':
    profile_multiprocessing_computation()  # Запускаем функцию профилирования при запуске программы

```
## Сравнительный анализ
+ **Asyncio**: Идеален для задач, связанных с вводом-выводом, где требуется высокая производительность и масштабируемость.
+ ** Threading**: Хорошо подходит для параллельной обработки задач, связанных с ожиданием, особенно в многозадачных приложениях.
+ ** Multiprocessing**: Эффективен для задач, требующих интенсивных вычислений и использования нескольких ядер процессора.
## Заключение
Проект показал, что каждый подход имеет свои сильные и слабые стороны в зависимости от специфики задачи. Полученные результаты могут быть полезны для выбора оптимального подхода при разработке высокопроизводительных приложений на Python.

